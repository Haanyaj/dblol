{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Haan\\\\Documents\\\\reactlol\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"C:\\\\Users\\\\Haan\\\\Documents\\\\reactlol\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:\\\\Users\\\\Haan\\\\Documents\\\\reactlol\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Haan\\\\Documents\\\\reactlol\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { useState, useEffect } from 'react';\nvar stores = {};\nvar subscriptions = {};\n\nvar defaultReducer = function defaultReducer(state, payload) {\n  return payload;\n};\n/** The public interface of a store */\n\n\nvar StoreInterface =\n/*#__PURE__*/\nfunction () {\n  function StoreInterface(name, store, useReducer) {\n    _classCallCheck(this, StoreInterface);\n\n    this.name = name;\n    useReducer ? this.dispatch = store.setState : this.setState = store.setState;\n\n    this.getState = function () {\n      return store.state;\n    };\n\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Subscribe to store changes\n   * @callback callback - The function to be invoked everytime the store is updated\n   * @return {Function} - Call the function returned by the method to cancel the subscription\n   */\n\n  /**\n  *\n  * @param {callback} state, action\n  */\n\n\n  _createClass(StoreInterface, [{\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      var _this = this;\n\n      if (!callback || typeof callback !== 'function') {\n        throw \"store.subscribe callback argument must be a function. got '\".concat(typeof callback, \"' instead.\");\n      }\n\n      if (subscriptions[this.name].find(function (c) {\n        return c === callback;\n      })) {\n        console.warn('This callback is already subscribed to this store. skipping subscription');\n        return;\n      }\n\n      subscriptions[this.name].push(callback);\n      return function () {\n        subscriptions[_this.name] = subscriptions[_this.name].filter(function (c) {\n          return c !== callback;\n        });\n      };\n    }\n  }, {\n    key: \"setState\",\n    value: function setState() {\n      console.warn(\"[React Hookstore] Store \".concat(this.name, \" uses a reducer to handle its state updates. use dispatch instead of setState\"));\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch() {\n      console.warn(\"[React Hookstore] Store \".concat(this.name, \" does not use a reducer to handle state updates. use setState instead of dispatch\"));\n    }\n  }]);\n\n  return StoreInterface;\n}();\n\nfunction getStoreByIdentifier(identifier) {\n  var name = identifier instanceof StoreInterface ? identifier.name : identifier;\n\n  if (!stores[name]) {\n    throw \"Store with name \".concat(name, \" does not exist\");\n  }\n\n  return stores[name];\n}\n/**\n * Creates a new store\n * @param {String} name - The store namespace.\n * @param {*} state [{}] - The store initial state. It can be of any type.\n * @callback reducer [null]\n * @returns {StoreInterface} The store instance.\n */\n\n/**\n *\n * @param {reducer} prevState, action - The reducer handler. Optional.\n */\n\n\nexport function createStore(name) {\n  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var reducer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultReducer;\n\n  if (typeof name !== 'string') {\n    throw 'Store name must be a string';\n  }\n\n  if (stores[name]) {\n    throw \"Store with name \".concat(name, \" already exists\");\n  }\n\n  var store = {\n    state: state,\n    reducer: reducer,\n    setState: function setState(action, callback) {\n      var _this2 = this;\n\n      this.state = this.reducer(this.state, action);\n      this.setters.forEach(function (setter) {\n        return setter(_this2.state);\n      });\n\n      if (subscriptions[name].length) {\n        subscriptions[name].forEach(function (c) {\n          return c(_this2.state, action);\n        });\n      }\n\n      if (typeof callback === 'function') callback(this.state);\n    },\n    setters: []\n  };\n  store.setState = store.setState.bind(store);\n  subscriptions[name] = [];\n  store.public = new StoreInterface(name, store, reducer !== defaultReducer);\n  stores = Object.assign({}, stores, _defineProperty({}, name, store));\n  return store.public;\n}\n/**\n * Returns a store instance based on its name\n * @callback {String} name - The name of the wanted store\n * @returns {StoreInterface} the store instance\n */\n\nexport function getStoreByName(name) {\n  try {\n    return stores[name].public;\n  } catch (e) {\n    throw \"Store with name \".concat(name, \" does not exist\");\n  }\n}\n/**\n * Returns a [ state, setState ] pair for the selected store. Can only be called within React Components\n * @param {String|StoreInterface} identifier - The identifier for the wanted store\n * @returns {Array} the [state, setState] pair.\n */\n\nexport function useStore(identifier) {\n  var store = getStoreByIdentifier(identifier);\n\n  var _useState = useState(store.state),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      set = _useState2[1];\n\n  useEffect(function () {\n    if (!store.setters.includes(set)) {\n      store.setters.push(set);\n    }\n\n    return function () {\n      store.setters = store.setters.filter(function (setter) {\n        return setter !== set;\n      });\n    };\n  }, []);\n  return [state, store.setState];\n}","map":{"version":3,"sources":["C:/Users/Haan/Documents/reactlol/node_modules/react-hookstore/src/index.js"],"names":["useState","useEffect","stores","subscriptions","defaultReducer","state","payload","StoreInterface","name","store","useReducer","dispatch","setState","getState","subscribe","bind","callback","find","c","console","warn","push","filter","getStoreByIdentifier","identifier","createStore","reducer","action","setters","forEach","setter","length","public","Object","assign","getStoreByName","e","useStore","set","includes"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\n\nlet stores = {};\nlet subscriptions = {};\n\nconst defaultReducer = (state, payload) => payload;\n\n/** The public interface of a store */\nclass StoreInterface {\n  constructor(name, store, useReducer) {\n    this.name = name;\n    useReducer ?\n      this.dispatch = store.setState : this.setState = store.setState;\n    this.getState = () => store.state;\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  /**\n   * Subscribe to store changes\n   * @callback callback - The function to be invoked everytime the store is updated\n   * @return {Function} - Call the function returned by the method to cancel the subscription\n   */\n\n  /**\n  *\n  * @param {callback} state, action\n  */\n  subscribe(callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw `store.subscribe callback argument must be a function. got '${typeof callback}' instead.`;\n    }\n    if (subscriptions[this.name].find(c => c === callback)) {\n      console.warn('This callback is already subscribed to this store. skipping subscription');\n      return;\n    }\n    subscriptions[this.name].push(callback);\n    return () => {\n      subscriptions[this.name] = subscriptions[this.name].filter(c => c !== callback);\n    }\n  }\n\n  setState() {\n    console.warn(`[React Hookstore] Store ${this.name} uses a reducer to handle its state updates. use dispatch instead of setState`)\n  }\n\n  dispatch() {\n    console.warn(`[React Hookstore] Store ${this.name} does not use a reducer to handle state updates. use setState instead of dispatch`)\n  }\n}\n\nfunction getStoreByIdentifier(identifier) {\n  const name = identifier instanceof StoreInterface ? identifier.name : identifier;\n  if (!stores[name]) {\n    throw `Store with name ${name} does not exist`;\n  }\n  return stores[name];\n}\n\n/**\n * Creates a new store\n * @param {String} name - The store namespace.\n * @param {*} state [{}] - The store initial state. It can be of any type.\n * @callback reducer [null]\n * @returns {StoreInterface} The store instance.\n */\n\n /**\n  *\n  * @param {reducer} prevState, action - The reducer handler. Optional.\n  */\nexport function createStore(name, state = {}, reducer=defaultReducer) {\n  if (typeof name !== 'string') {\n    throw 'Store name must be a string';\n  }\n  if (stores[name]) {\n    throw `Store with name ${name} already exists`;\n  }\n\n  const store = {\n    state,\n    reducer,\n    setState(action, callback) {\n      this.state = this.reducer(this.state, action);\n      this.setters.forEach(setter => setter(this.state));\n      if (subscriptions[name].length) {\n        subscriptions[name].forEach(c => c(this.state, action));\n      }\n      if (typeof callback === 'function') callback(this.state)\n    },\n    setters: []\n  };\n  store.setState = store.setState.bind(store);\n  subscriptions[name] = [];\n  store.public = new StoreInterface(name, store, reducer !== defaultReducer);\n\n  stores = Object.assign({}, stores, { [name]: store });\n  return store.public;\n}\n\n/**\n * Returns a store instance based on its name\n * @callback {String} name - The name of the wanted store\n * @returns {StoreInterface} the store instance\n */\n\nexport function getStoreByName(name) {\n  try {\n    return stores[name].public;\n  } catch(e) {\n    throw `Store with name ${name} does not exist`;\n  }\n}\n\n/**\n * Returns a [ state, setState ] pair for the selected store. Can only be called within React Components\n * @param {String|StoreInterface} identifier - The identifier for the wanted store\n * @returns {Array} the [state, setState] pair.\n */\nexport function useStore(identifier) {\n  const store = getStoreByIdentifier(identifier);\n\n  const [ state, set ] = useState(store.state);\n\n  useEffect(() => {\n    if (!store.setters.includes(set)) {\n      store.setters.push(set);\n    }\n\n    return () => {\n      store.setters = store.setters.filter(setter => setter !== set)\n    }\n  }, [])\n\n  return [ state, store.setState ];\n}\n"]},"metadata":{},"sourceType":"module"}